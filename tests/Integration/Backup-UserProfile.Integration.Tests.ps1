#Requires -Version 5.1
#Requires -Modules @{ ModuleName = 'Pester'; ModuleVersion = '5.0.0' }

# BeforeDiscovery runs before test discovery - variables defined here are available for -Skip parameters
BeforeDiscovery {
    # Check if running as Administrator
    $script:SkipNonAdminTests = -not ([Security.Principal.WindowsPrincipal]::new(
        [Security.Principal.WindowsIdentity]::GetCurrent()
    )).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
    
    if ($script:SkipNonAdminTests) {
        Write-Host "NOTE: Running without Administrator privileges - Some ACL tests will be skipped" -ForegroundColor Yellow
    }
}

<#
.SYNOPSIS
    Integration tests for Backup-UserProfile script.

.DESCRIPTION
    These tests validate the Backup-UserProfile.ps1 script using generated test data.
    Tests cover both Mirror and Compress backup modes, NTFS permission configuration,
    and various edge cases.

.NOTES
    Author: SecureProfileBackup Test Framework
    Version: 2.0.0

    Prerequisites:
    - Pester 5.x
    - Administrator privileges (for NTFS permission tests)
    - NTFSSecurity module (mocked for non-admin tests)
    - Test data generated by New-TestProfiles.ps1
#>

BeforeAll {
    # Set up paths relative to test file location
    $script:ProjectRoot = Split-Path -Parent (Split-Path -Parent $PSScriptRoot)
    $script:SourcePath = Join-Path -Path $script:ProjectRoot -ChildPath 'source'
    $script:OutputPath = Join-Path -Path $script:ProjectRoot -ChildPath 'output'
    $script:TestProfilesPath = Join-Path -Path $script:OutputPath -ChildPath 'TestProfiles'
    $script:TestBackupPath = Join-Path -Path $script:OutputPath -ChildPath 'TestBackups'
    $script:HelpersPath = Join-Path -Path (Split-Path -Parent $PSScriptRoot) -ChildPath 'helpers'

    # Path to the script under test
    $script:BackupScriptPath = Join-Path -Path $script:SourcePath -ChildPath 'Backup-UserProfile.ps1'

    # Create a test version without the RunAsAdministrator requirement
    $script:TestScriptPath = Join-Path -Path $script:OutputPath -ChildPath 'Backup-UserProfile.Test.ps1'

    # Ensure output directory exists
    if (-not (Test-Path -Path $script:OutputPath)) {
        New-Item -Path $script:OutputPath -ItemType Directory -Force | Out-Null
    }

    # Read and modify the script for testing
    $scriptContent = Get-Content -Path $script:BackupScriptPath -Raw
    $testScriptContent = $scriptContent -replace '#Requires -RunAsAdministrator', '# RunAsAdministrator removed for testing'
    Set-Content -Path $script:TestScriptPath -Value $testScriptContent -Encoding UTF8

    # Define a wrapper function that invokes the script with parameters
    # Note: SupportsShouldProcess automatically provides -WhatIf and -Confirm parameters
    # Do NOT define them explicitly or you'll get "parameter defined multiple times" error
    function Invoke-BackupUserProfile {
        [CmdletBinding(SupportsShouldProcess)]
        param(
            [string]$SourcePath,
            [string]$TargetPath,
            [string]$BackupMode = 'Mirror',
            [string]$ProfilePattern = '^\d+$',
            [string[]]$AdditionalSids,
            [string]$SidFilterPattern = 'S-1-5-21-1230*',
            [string]$NTFSSecurityModulePath,
            [string]$CompressionLevel = 'Optimal'
        )
        
        $scriptParams = @{}
        if ($SourcePath) { $scriptParams['SourcePath'] = $SourcePath }
        if ($TargetPath) { $scriptParams['TargetPath'] = $TargetPath }
        if ($BackupMode) { $scriptParams['BackupMode'] = $BackupMode }
        if ($ProfilePattern) { $scriptParams['ProfilePattern'] = $ProfilePattern }
        if ($AdditionalSids) { $scriptParams['AdditionalSids'] = $AdditionalSids }
        if ($SidFilterPattern) { $scriptParams['SidFilterPattern'] = $SidFilterPattern }
        if ($NTFSSecurityModulePath) { $scriptParams['NTFSSecurityModulePath'] = $NTFSSecurityModulePath }
        if ($CompressionLevel) { $scriptParams['CompressionLevel'] = $CompressionLevel }
        # Pass through ShouldProcess parameters from CmdletBinding
        if ($PSBoundParameters.ContainsKey('WhatIf')) { $scriptParams['WhatIf'] = $PSBoundParameters['WhatIf'] }
        if ($PSBoundParameters.ContainsKey('Confirm')) { $scriptParams['Confirm'] = $PSBoundParameters['Confirm'] }
        
        & $script:TestScriptPath @scriptParams
    }
    
    # Alias for backward compatibility with existing tests
    Set-Alias -Name Backup-UserProfile -Value Invoke-BackupUserProfile -Scope Script

    # Generate test profiles if they don't exist
    $testProfileGeneratorPath = Join-Path -Path $script:HelpersPath -ChildPath 'New-TestProfiles.ps1'

    if (-not (Test-Path -Path $script:TestProfilesPath)) {
        Write-Host "Generating test profiles..." -ForegroundColor Yellow
        & $testProfileGeneratorPath -OutputPath $script:TestProfilesPath -ProfileCount 3 -IncludeEdgeCases -CleanExisting -Verbose
    }

    # Create backup destination directory
    if (-not (Test-Path -Path $script:TestBackupPath)) {
        New-Item -Path $script:TestBackupPath -ItemType Directory -Force | Out-Null
    }

    # Create a mock NTFSSecurity module for testing without the actual module
    $mockModulePath = Join-Path -Path $script:OutputPath -ChildPath 'NTFSSecurity'
    if (-not (Test-Path -Path $mockModulePath)) {
        New-Item -Path $mockModulePath -ItemType Directory -Force | Out-Null
    }

    $mockModuleManifest = Join-Path -Path $mockModulePath -ChildPath 'NTFSSecurity.psd1'
    $mockModuleScript = Join-Path -Path $mockModulePath -ChildPath 'NTFSSecurity.psm1'

    # Create mock module manifest
    @"
@{
    RootModule = 'NTFSSecurity.psm1'
    ModuleVersion = '4.2.6'
    GUID = 'cd303a6c-f405-4dcb-b1ce-fbc2c52264e9'
    Author = 'Mock Module'
    Description = 'Mock NTFSSecurity module for testing'
    FunctionsToExport = @('Add-NTFSAccess', 'Get-NTFSAccess', 'Get-NTFSInheritance', 'Disable-NTFSAccessInheritance', 'Get-NTFSAccessCallLog', 'Get-DisableInheritanceCallLog', 'Clear-NTFSMockCallLogs')
}
"@ | Set-Content -Path $mockModuleManifest -Encoding UTF8

    # Create mock module functions with call tracking for verification (using PSCustomObject for better property access)
    @'
# Script-scoped variables to track function calls
$script:NTFSAccessCalls = [System.Collections.Generic.List[PSCustomObject]]::new()
$script:DisableInheritanceCalls = [System.Collections.Generic.List[PSCustomObject]]::new()
$script:GetNTFSAccessCalls = [System.Collections.Generic.List[PSCustomObject]]::new()
# Store profile owner SIDs when they are added (for test profiles with random ACLs)
$script:ProfileOwnerSids = @{}

function Add-NTFSAccess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [Parameter()]
        [string]$Account,

        [Parameter()]
        [string]$AccessRights,

        [Parameter()]
        [string]$AppliesTo
    )

    # Track the call for verification using PSCustomObject for easy property access
    $script:NTFSAccessCalls.Add([PSCustomObject]@{
        Path         = $Path
        Account      = $Account
        AccessRights = $AccessRights
        AppliesTo    = $AppliesTo
        Timestamp    = Get-Date
    })

    # If this is a SID being added to a test profile (not a backup destination), store it
    # This allows Get-NTFSAccess to return the profile owner SID later
    if ($Account -match '^S-1-5-21-' -and $Path -match 'TestProfiles') {
        $script:ProfileOwnerSids[$Path] = $Account
        Write-Verbose "Mock: Stored profile owner SID for $Path : $Account"
    }

    Write-Verbose "Mock: Adding $AccessRights for $Account to $Path"
    # Do NOT return anything - the real Add-NTFSAccess doesn't output by default
}

function Get-NTFSAccess {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path
    )

    # Track the call for verification
    $script:GetNTFSAccessCalls.Add([PSCustomObject]@{
        Path      = $Path
        Timestamp = Get-Date
    })

    Write-Verbose "Mock: Getting NTFS access for $Path"

    # Check if we have a stored profile owner SID for this path
    $ownerSid = $null
    if ($script:ProfileOwnerSids.ContainsKey($Path)) {
        $ownerSid = $script:ProfileOwnerSids[$Path]
        Write-Verbose "Mock: Found stored owner SID: $ownerSid"
    } else {
        # Generate a SID in the correct domain space based on profile name
        # Domain SID: S-1-5-21-1230772385-5638642905-859402768
        $profileName = [System.IO.Path]::GetFileName($Path)
        if ($profileName -match '^\d+$') {
            $rid = [int]$profileName
        } else {
            $rid = [Math]::Abs($profileName.GetHashCode()) % 100000 + 500000
        }
        $ownerSid = "S-1-5-21-1230772385-5638642905-859402768-$rid"
        Write-Verbose "Mock: Generated domain SID: $ownerSid"
    }

    # Return mock ACL entries simulating a user profile owner
    @(
        [PSCustomObject]@{
            Path         = $Path
            Account      = [PSCustomObject]@{
                Sid         = $ownerSid
                AccountName = "TestUser_$([System.IO.Path]::GetFileName($Path))"
            }
            AccessRights = 'FullControl'
            IsInherited  = $false
        }
    )
}

function Disable-NTFSAccessInheritance {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path,

        [Parameter()]
        [switch]$RemoveInheritedAccessRules
    )

    # Track the call for verification using PSCustomObject for easy property access
    $script:DisableInheritanceCalls.Add([PSCustomObject]@{
        Path                       = $Path
        RemoveInheritedAccessRules = $RemoveInheritedAccessRules.IsPresent
        Timestamp                  = Get-Date
    })

    Write-Verbose "Mock: Disabling inheritance for $Path (Remove: $RemoveInheritedAccessRules)"
    # Do NOT return anything
}

function Get-NTFSInheritance {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path
    )

    Write-Verbose "Mock: Getting NTFS inheritance for $Path"

    # Check if inheritance was disabled for this path
    $wasDisabled = $script:DisableInheritanceCalls | Where-Object { $_.Path -eq $Path }

    # Return mock inheritance info
    [PSCustomObject]@{
        Path                        = $Path
        AccessInheritanceEnabled    = ($null -eq $wasDisabled)
        AuditInheritanceEnabled     = ($null -eq $wasDisabled)
    }
}

function Get-NTFSAccessCallLog {
    [CmdletBinding()]
    param()
    return $script:NTFSAccessCalls
}

function Get-DisableInheritanceCallLog {
    [CmdletBinding()]
    param()
    return $script:DisableInheritanceCalls
}

function Clear-NTFSMockCallLogs {
    [CmdletBinding()]
    param()
    $script:NTFSAccessCalls.Clear()
    $script:DisableInheritanceCalls.Clear()
    $script:GetNTFSAccessCalls.Clear()
}

Export-ModuleMember -Function Add-NTFSAccess, Get-NTFSAccess, Get-NTFSInheritance, Disable-NTFSAccessInheritance, Get-NTFSAccessCallLog, Get-DisableInheritanceCallLog, Clear-NTFSMockCallLogs
'@ | Set-Content -Path $mockModuleScript -Encoding UTF8
}

AfterAll {
    # Cleanup test backup directory
    if (Test-Path -Path $script:TestBackupPath) {
        Remove-Item -Path $script:TestBackupPath -Recurse -Force -ErrorAction SilentlyContinue
    }

    # Cleanup test script
    $testScriptPath = Join-Path -Path $script:OutputPath -ChildPath 'Backup-UserProfile.Test.ps1'
    if (Test-Path -Path $testScriptPath) {
        Remove-Item -Path $testScriptPath -Force -ErrorAction SilentlyContinue
    }
}

Describe 'Backup-UserProfile Integration Tests' -Tag 'Integration' {
    BeforeAll {
        $mockModulePath = Join-Path -Path $script:OutputPath -ChildPath 'NTFSSecurity\NTFSSecurity.psd1'
    }

    Context 'Parameter Validation' {
        It 'Should have mandatory parameters with defaults' {
            $command = Get-Command -Name Backup-UserProfile
            $command | Should -Not -BeNullOrEmpty

            # Check that SourcePath parameter exists
            $sourcePathParam = $command.Parameters['SourcePath']
            $sourcePathParam | Should -Not -BeNullOrEmpty

            # Check that TargetPath parameter exists
            $targetPathParam = $command.Parameters['TargetPath']
            $targetPathParam | Should -Not -BeNullOrEmpty

            # Check that BackupMode parameter exists with a default value
            $backupModeParam = $command.Parameters['BackupMode']
            $backupModeParam | Should -Not -BeNullOrEmpty
            
            # Note: The wrapper function passes BackupMode to the underlying script,
            # which has the ValidateSet attribute. We verify the script validation works
            # by testing that invalid modes fail in the script execution tests.
        }

        It 'Should validate SourcePath exists' {
            { Backup-UserProfile -SourcePath 'C:\NonExistentPath12345' -WhatIf } | Should -Throw
        }

        It 'Should support WhatIf' {
            $command = Get-Command -Name Backup-UserProfile
            $command.Parameters.ContainsKey('WhatIf') | Should -BeTrue
        }

        It 'Should support Confirm' {
            $command = Get-Command -Name Backup-UserProfile
            $command.Parameters.ContainsKey('Confirm') | Should -BeTrue
        }
    }

    Context 'Mirror Mode Backup' {
        BeforeEach {
            # Clean backup directory before each test
            $mirrorBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Mirror'
            if (Test-Path -Path $mirrorBackupPath) {
                Remove-Item -Path $mirrorBackupPath -Recurse -Force
            }
            New-Item -Path $mirrorBackupPath -ItemType Directory -Force | Out-Null
        }

        It 'Should find profiles matching the pattern' {
            $profiles = Get-ChildItem -Path $script:TestProfilesPath -Directory |
                Where-Object { $_.Name -match '^\d+$' }

            $profiles.Count | Should -BeGreaterThan 0
            Write-Host "Found $($profiles.Count) numeric profile directories"
        }

        It 'Should execute without errors in WhatIf mode' {
            $mirrorBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Mirror'

            # WhatIf mode should not throw errors
            { Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $mirrorBackupPath `
                -BackupMode Mirror `
                -NTFSSecurityModulePath $mockModulePath `
                -WhatIf `
                -Confirm:$false } | Should -Not -Throw

            # WhatIf should not create actual backups
            $backupDirs = @(Get-ChildItem -Path $mirrorBackupPath -Directory -ErrorAction SilentlyContinue)
            $backupDirs.Count | Should -Be 0
        }

        It 'Should create backup directories for each profile' {
            $mirrorBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Mirror'

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $mirrorBackupPath `
                -BackupMode Mirror `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $results | Should -Not -BeNullOrEmpty
            $results.Count | Should -BeGreaterThan 0

            # Verify backup directories were created
            foreach ($result in $results) {
                $result.DestinationPath | Should -Exist
                $result.BackupMode | Should -Be 'Mirror'
            }
        }

        It 'Should return PSCustomObject results with expected properties' {
            $mirrorBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Mirror'

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $mirrorBackupPath `
                -BackupMode Mirror `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $results | ForEach-Object {
                $_ | Should -BeOfType [PSCustomObject]
                $_.PSObject.Properties.Name | Should -Contain 'ProfileName'
                $_.PSObject.Properties.Name | Should -Contain 'SourcePath'
                $_.PSObject.Properties.Name | Should -Contain 'DestinationPath'
                $_.PSObject.Properties.Name | Should -Contain 'BackupMode'
                $_.PSObject.Properties.Name | Should -Contain 'Status'
                $_.PSObject.Properties.Name | Should -Contain 'RobocopyExitCode'
            }
        }

        It 'Should set successful status for completed backups' {
            $mirrorBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Mirror'

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $mirrorBackupPath `
                -BackupMode Mirror `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $successfulBackups = $results | Where-Object { $_.Status -eq 'Success' }
            $successfulBackups.Count | Should -BeGreaterThan 0
        }
    }

    Context 'Compress Mode Backup' {
        BeforeEach {
            # Clean backup directory before each test
            $compressBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Compress'
            if (Test-Path -Path $compressBackupPath) {
                Remove-Item -Path $compressBackupPath -Recurse -Force
            }
            New-Item -Path $compressBackupPath -ItemType Directory -Force | Out-Null
        }

        It 'Should create ZIP archives for each profile' {
            $compressBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Compress'

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $compressBackupPath `
                -BackupMode Compress `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $results | Should -Not -BeNullOrEmpty

            # Verify ZIP files were created
            foreach ($result in $results | Where-Object { $_.Status -eq 'Success' }) {
                $result.DestinationPath | Should -Exist
                $result.DestinationPath | Should -Match '\.zip$'
                $result.BackupMode | Should -Be 'Compress'
            }
        }

        It 'Should report compressed size for ZIP archives' {
            $compressBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Compress'

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $compressBackupPath `
                -BackupMode Compress `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $successfulBackups = $results | Where-Object { $_.Status -eq 'Success' }

            foreach ($backup in $successfulBackups) {
                $backup.CompressedSize | Should -BeGreaterThan 0
            }
        }

        It 'Should support different compression levels' {
            $compressBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Compress'

            # Test Fastest compression
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $compressBackupPath `
                -BackupMode Compress `
                -CompressionLevel Fastest `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $results | Should -Not -BeNullOrEmpty
            $successfulBackups = $results | Where-Object { $_.Status -eq 'Success' }
            $successfulBackups.Count | Should -BeGreaterThan 0
        }

        It 'Should overwrite existing ZIP archives' {
            $compressBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Compress'

            # First backup
            $results1 = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $compressBackupPath `
                -BackupMode Compress `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            # Get first archive's timestamp
            $firstArchive = $results1 | Where-Object { $_.Status -eq 'Success' } | Select-Object -First 1
            $firstTimestamp = (Get-Item -Path $firstArchive.DestinationPath).LastWriteTime

            Start-Sleep -Seconds 1

            # Second backup (should overwrite)
            $results2 = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $compressBackupPath `
                -BackupMode Compress `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $secondArchive = $results2 | Where-Object { $_.ProfileName -eq $firstArchive.ProfileName }
            $secondTimestamp = (Get-Item -Path $secondArchive.DestinationPath).LastWriteTime

            $secondTimestamp | Should -BeGreaterThan $firstTimestamp
        }
    }

    Context 'Edge Case Handling' {
        BeforeEach {
            $edgeCaseBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'EdgeCases'
            if (Test-Path -Path $edgeCaseBackupPath) {
                Remove-Item -Path $edgeCaseBackupPath -Recurse -Force
            }
            New-Item -Path $edgeCaseBackupPath -ItemType Directory -Force | Out-Null
        }

        It 'Should handle empty profile directories' {
            $edgeCaseBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'EdgeCases'

            # Profile 99991 is the empty edge case
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $edgeCaseBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^99991$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            # Should handle empty directory without error
            $results | Should -Not -BeNullOrEmpty
        }

        It 'Should handle profiles with special character filenames' {
            $edgeCaseBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'EdgeCases'

            # Profile 99992 has special characters
            $results = @(Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $edgeCaseBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^99992$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false)

            $results.Count | Should -BeGreaterThan 0
            ($results | Select-Object -First 1).Status | Should -Be 'Success'
        }

        It 'Should handle deeply nested directories' {
            $edgeCaseBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'EdgeCases'

            # Profile 99993 has 15 levels of nesting
            $results = @(Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $edgeCaseBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^99993$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false)

            $results.Count | Should -BeGreaterThan 0
            ($results | Select-Object -First 1).Status | Should -Be 'Success'
        }

        It 'Should handle profiles with many files' {
            $edgeCaseBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'EdgeCases'

            # Profile 99995 has 100 files
            $results = @(Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $edgeCaseBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^99995$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false)

            $results.Count | Should -BeGreaterThan 0
            ($results | Select-Object -First 1).Status | Should -Be 'Success'
            ($results | Select-Object -First 1).CompressedSize | Should -BeGreaterThan 0
        }
    }

    Context 'Profile Pattern Matching' {
        It 'Should only backup profiles matching the pattern' {
            $patternBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Pattern'
            if (Test-Path -Path $patternBackupPath) {
                Remove-Item -Path $patternBackupPath -Recurse -Force
            }
            New-Item -Path $patternBackupPath -ItemType Directory -Force | Out-Null

            # Only match profiles starting with 1000
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $patternBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^1000\d$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            # Should only find profiles 10000, 10001, 10002
            $results.Count | Should -BeLessOrEqual 3
            $results | ForEach-Object {
                $_.ProfileName | Should -Match '^1000\d$'
            }
        }

        It 'Should return empty results for non-matching pattern' {
            $patternBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Pattern'
            if (Test-Path -Path $patternBackupPath) {
                Remove-Item -Path $patternBackupPath -Recurse -Force
            }
            New-Item -Path $patternBackupPath -ItemType Directory -Force | Out-Null

            $results = @(Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $patternBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^NOMATCH\d+$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false)

            $results.Count | Should -Be 0
        }
    }

    Context 'Error Handling' {
        It 'Should throw when NTFSSecurity module is not found' {
            { Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $script:TestBackupPath `
                -NTFSSecurityModulePath 'C:\NonExistent\Module.psd1' `
                -WhatIf
            } | Should -Throw
        }

        It 'Should create target directory if it does not exist' {
            $newTargetPath = Join-Path -Path $script:TestBackupPath -ChildPath 'NewDirectory'

            if (Test-Path -Path $newTargetPath) {
                Remove-Item -Path $newTargetPath -Recurse -Force
            }

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $newTargetPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            Test-Path -Path $newTargetPath | Should -BeTrue
        }
    }

    Context 'Verbose Output' {
        It 'Should provide verbose output when requested' {
            $verboseBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Verbose'
            if (Test-Path -Path $verboseBackupPath) {
                Remove-Item -Path $verboseBackupPath -Recurse -Force
            }
            New-Item -Path $verboseBackupPath -ItemType Directory -Force | Out-Null

            $verboseOutput = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $verboseBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Verbose `
                -Confirm:$false 4>&1

            # Verbose stream should contain messages
            $verboseOutput | Should -Not -BeNullOrEmpty
        }
    }
}

Describe 'Backup-UserProfile NTFS Permission Tests (Mock)' -Tag 'Integration', 'ACL', 'Mock' {
    BeforeAll {
        $mockModulePath = Join-Path -Path $script:OutputPath -ChildPath 'NTFSSecurity\NTFSSecurity.psd1'
        
        # Import the mock module to access call logs
        Import-Module $mockModulePath -Force
    }

    BeforeEach {
        # Clear call logs before each test
        Clear-NTFSMockCallLogs

        $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'
        if (Test-Path -Path $aclBackupPath) {
            Remove-Item -Path $aclBackupPath -Recurse -Force
        }
        New-Item -Path $aclBackupPath -ItemType Directory -Force | Out-Null
    }

    Context 'Mirror Mode ACL Configuration (Mock Verification)' {
        It 'Should add Administrators FullControl permission' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-NTFSAccessCallLog)
            $adminCalls = @($calls | Where-Object { $_.Account -eq 'Administrators' -and $_.AccessRights -eq 'FullControl' })
            $adminCalls.Count | Should -BeGreaterThan 0
        }

        It 'Should add SYSTEM FullControl permission' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-NTFSAccessCallLog)
            $systemCalls = @($calls | Where-Object { $_.Account -eq 'NT Authority\SYSTEM' -and $_.AccessRights -eq 'FullControl' })
            $systemCalls.Count | Should -BeGreaterThan 0
        }

        It 'Should NOT grant Users access (v2.3.0 security model)' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-NTFSAccessCallLog)
            # Per v2.3.0 security model: BUILTIN\Users should NOT have any access to backups
            $userCalls = @($calls | Where-Object { $_.Account -eq 'Users' })
            $userCalls.Count | Should -Be 0 -Because "BUILTIN\Users should have NO access to backup directories (v2.3.0 security model)"
        }

        It 'Should add additional SID permissions' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'
            $testSid = 'S-1-5-21-1230772385-5638642905-859402768-588602'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -AdditionalSids @($testSid) `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-NTFSAccessCallLog)
            $sidCalls = @($calls | Where-Object { $_.Account -eq $testSid -and $_.AccessRights -eq 'FullControl' })
            $sidCalls.Count | Should -BeGreaterThan 0
        }

        It 'Should disable inheritance and remove inherited rules' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-DisableInheritanceCallLog)
            $calls.Count | Should -BeGreaterThan 0
            $calls[0].RemoveInheritedAccessRules | Should -BeTrue
        }

        It 'Should replicate profile owner permissions from source' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = Get-NTFSAccessCallLog
            # Mock returns a SID matching the pattern, verify it was added
            $replicatedCalls = $calls | Where-Object { 
                $_.Account -and 
                $_.Account.ToString() -like '*S-1-5-21-1230*' -and
                $_.AccessRights -eq 'FullControl'
            }
            $replicatedCalls.Count | Should -BeGreaterThan 0
        }

        It 'Should replicate random profile owner SID with wildcard SidFilterPattern' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            # Use wildcard pattern to match any S-1-5-21-* SID (for random test ACLs)
            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -SidFilterPattern 'S-1-5-21-*' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = Get-NTFSAccessCallLog
            # Should have replicated any S-1-5-21-* SID with FullControl
            $replicatedCalls = @($calls | Where-Object { 
                $_.Account -and 
                $_.Account.ToString() -like '*S-1-5-21-*' -and
                $_.AccessRights -eq 'FullControl' -and
                $_.Path -notlike '*TestProfiles*'  # Only backup destination, not source
            })
            $replicatedCalls.Count | Should -BeGreaterThan 0 -Because "Profile owner SID should be replicated to backup with wildcard SidFilterPattern"
        }
    }

    Context 'Profile Owner ACL Replication' {
        It 'Should replicate profile owner ACL from test profile to Mirror backup' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            # Backup with wildcard SID pattern to match random test profile ACLs
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -SidFilterPattern 'S-1-5-21-*' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $results | Should -Not -BeNullOrEmpty
            $results[0].Status | Should -Be 'Success'

            $calls = @(Get-NTFSAccessCallLog)
            
            # Verify profile owner SID was added to backup destination
            $backupPath = $results[0].DestinationPath
            $ownerCalls = @($calls | Where-Object { 
                $_.Path -eq $backupPath -and
                $_.Account -like 'S-1-5-21-*' -and
                $_.AccessRights -eq 'FullControl'
            })
            
            $ownerCalls.Count | Should -BeGreaterThan 0 -Because "Profile owner SID should be replicated to backup directory"
            Write-Host "Verified: Profile owner SID replicated to backup: $($ownerCalls[0].Account)"
        }

        It 'Should replicate profile owner ACL from test profile to ZIP backup' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            # Backup with wildcard SID pattern to match random test profile ACLs
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -SidFilterPattern 'S-1-5-21-*' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $results | Should -Not -BeNullOrEmpty
            $results[0].Status | Should -Be 'Success'

            $calls = @(Get-NTFSAccessCallLog)
            
            # Verify profile owner SID was added to ZIP archive
            $zipPath = $results[0].DestinationPath
            $ownerCalls = @($calls | Where-Object { 
                $_.Path -eq $zipPath -and
                $_.Account -like 'S-1-5-21-*' -and
                $_.AccessRights -eq 'FullControl'
            })
            
            $ownerCalls.Count | Should -BeGreaterThan 0 -Because "Profile owner SID should be replicated to ZIP archive"
            Write-Host "Verified: Profile owner SID replicated to ZIP: $($ownerCalls[0].Account)"
        }
    }

    Context 'Compress Mode ACL Configuration (Mock Verification)' {
        It 'Should add Administrators FullControl to ZIP archive' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-NTFSAccessCallLog)
            $adminCalls = @($calls | Where-Object { 
                $_.Account -eq 'Administrators' -and 
                $_.AccessRights -eq 'FullControl' -and
                $_.Path -like '*.zip'
            })
            $adminCalls.Count | Should -BeGreaterThan 0
        }

        It 'Should NOT grant Users access to ZIP archive (v2.3.0 security model)' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-NTFSAccessCallLog)
            # Per v2.3.0 security model: BUILTIN\Users should NOT have any access to ZIP archives
            $userCalls = @($calls | Where-Object { 
                $_.Account -eq 'Users' -and
                $_.Path -like '*.zip'
            })
            $userCalls.Count | Should -Be 0 -Because "BUILTIN\Users should have NO access to ZIP archives (v2.3.0 security model)"
        }

        It 'Should disable inheritance on ZIP archive' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $calls = @(Get-DisableInheritanceCallLog)
            $zipCalls = @($calls | Where-Object { $_.Path -like '*.zip' })
            $zipCalls.Count | Should -BeGreaterThan 0
            $zipCalls[0].RemoveInheritedAccessRules | Should -BeTrue
        }
    }

    Context 'ACL Call Order Verification' {
        It 'Should call Add-NTFSAccess before Disable-NTFSAccessInheritance' {
            $aclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'ACL'

            Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $aclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false | Out-Null

            $accessCalls = @(Get-NTFSAccessCallLog)
            $inheritanceCalls = @(Get-DisableInheritanceCallLog)

            # Verify we have both types of calls
            $accessCalls.Count | Should -BeGreaterThan 0
            $inheritanceCalls.Count | Should -BeGreaterThan 0

            # First Add-NTFSAccess should happen before or at same time as Disable-NTFSAccessInheritance
            # (timestamps can be identical when calls happen in quick succession)
            $firstAccessCall = $accessCalls[0].Timestamp
            $firstInheritanceCall = $inheritanceCalls[0].Timestamp

            $firstAccessCall | Should -BeLessOrEqual $firstInheritanceCall
        }
    }
}

Describe 'Backup-UserProfile NTFS Permission Tests (Real ACL Verification)' -Tag 'Integration', 'ACL', 'RealACL' {
    <#
    .SYNOPSIS
        Tests that actually verify ACL changes using NTFSSecurity module.
        
    .DESCRIPTION
        These tests perform actual backup operations and verify that NTFS permissions
        are correctly applied to backup files/directories using the NTFSSecurity module
        (Get-NTFSAccess, Get-NTFSInheritance).
        
        This provides real integration testing of the ACL functionality, verifying:
        - Administrators have FullControl
        - SYSTEM has FullControl  
        - Users have NO access (v2.3.0 security model)
        - Inheritance is disabled (REQUIRES ADMIN PRIVILEGES)
        
    .NOTES
        IMPORTANT: ACL modification tests require Administrator privileges to pass.
        When running without elevation:
        - File copy tests will pass
        - Permission verification may pass (due to inherited permissions)
        - Inheritance disable tests will FAIL (requires elevation)
        
        Run tests as Administrator for full ACL validation.
    #>
    
    BeforeAll {
        # Check if running as Administrator
        $currentPrincipal = [Security.Principal.WindowsPrincipal]::new([Security.Principal.WindowsIdentity]::GetCurrent())
        $script:IsAdmin = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
        
        if ($script:IsAdmin) {
            Write-Host "Running as ADMINISTRATOR - Full ACL tests will execute" -ForegroundColor Green
        } else {
            Write-Host "Running as STANDARD USER - ACL modification tests may fail" -ForegroundColor Yellow
            Write-Host "  (Inheritance disable requires Administrator privileges)" -ForegroundColor Yellow
        }
        
        # IMPORTANT: Remove any mock NTFSSecurity module that may have been loaded by previous tests
        # This ensures the real module is used for ACL verification
        Get-Module -Name NTFSSecurity -All | Remove-Module -Force -ErrorAction SilentlyContinue
        
        # Use the real NTFSSecurity module if available, otherwise use mock
        $realModulePath = $null
        $mockModulePath = Join-Path -Path $script:OutputPath -ChildPath 'NTFSSecurity\NTFSSecurity.psd1'
        
        # Check if real NTFSSecurity module is installed
        $installedModule = Get-Module -Name NTFSSecurity -ListAvailable -ErrorAction SilentlyContinue | Select-Object -First 1
        if ($installedModule) {
            $realModulePath = $installedModule.ModuleBase
            Write-Host "Using real NTFSSecurity module from: $realModulePath" -ForegroundColor Green
            $script:UsingRealModule = $true
            $script:ModulePathToUse = (Join-Path $realModulePath 'NTFSSecurity.psd1')
            
            # Pre-import the real module to ensure it takes precedence
            Import-Module -Name $script:ModulePathToUse -Force -ErrorAction SilentlyContinue
            Write-Host "Pre-imported real NTFSSecurity module" -ForegroundColor Green
        } else {
            Write-Host "Real NTFSSecurity module not found, using mock" -ForegroundColor Yellow
            $script:UsingRealModule = $false
            $script:ModulePathToUse = $mockModulePath
        }
    }
    
    BeforeEach {
        $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
        if (Test-Path -Path $realAclBackupPath) {
            Remove-Item -Path $realAclBackupPath -Recurse -Force
        }
        New-Item -Path $realAclBackupPath -ItemType Directory -Force | Out-Null
    }

    Context 'Mirror Mode - Actual ACL Verification' {
        It 'Should copy files to backup directory' {
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $results | Should -Not -BeNullOrEmpty
            $results[0].Status | Should -Be 'Success'
            
            # Verify files actually exist in backup
            $backupDir = $results[0].DestinationPath
            $backupDir | Should -Exist
            
            $filesInBackup = Get-ChildItem -Path $backupDir -Recurse -File
            $filesInBackup.Count | Should -BeGreaterThan 0
            
            Write-Host "Copied $($filesInBackup.Count) files to backup directory"
        }
        
        It 'Should set Administrators FullControl permission (verified with Get-NTFSAccess)' {
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $backupDir = $results[0].DestinationPath
            
            # Use NTFSSecurity module to verify permissions
            $accessRules = Get-NTFSAccess -Path $backupDir
            $adminRules = $accessRules | Where-Object {
                $_.Account.AccountName -match 'Administrators' -and
                $_.AccessRights -match 'FullControl'
            }
            
            $adminRules | Should -Not -BeNullOrEmpty -Because "Administrators should have FullControl on backup directory"
            Write-Host "Verified: Administrators have FullControl"
        }
        
        It 'Should set SYSTEM FullControl permission (verified with Get-NTFSAccess)' {
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $backupDir = $results[0].DestinationPath
            
            # Use NTFSSecurity module to verify permissions
            $accessRules = Get-NTFSAccess -Path $backupDir
            $systemRules = $accessRules | Where-Object {
                $_.Account.AccountName -match 'SYSTEM' -and
                $_.AccessRights -match 'FullControl'
            }
            
            $systemRules | Should -Not -BeNullOrEmpty -Because "SYSTEM should have FullControl on backup directory"
            Write-Host "Verified: SYSTEM has FullControl"
        }
        
        It 'Should NOT have explicit Users access (v2.3.0 security model - inherited permissions may exist)' {
            # NOTE: This test verifies the v2.3.0 security model where BUILTIN\Users should NOT
            # be explicitly granted access. However, when running without Admin privileges or
            # when using the mock module, inherited permissions may still exist.
            # The key verification is that no EXPLICIT (non-inherited) Users rules are added.
            
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $backupDir = $results[0].DestinationPath
            
            # Use NTFSSecurity module to verify permissions  
            $accessRules = Get-NTFSAccess -Path $backupDir
            
            # Check for EXPLICIT (non-inherited) Users rules - there should be none per v2.3.0
            $explicitUserRules = $accessRules | Where-Object {
                $_.Account.AccountName -match 'Users' -and
                -not $_.IsInherited
            }
            
            # When running with real NTFSSecurity module and admin privileges, there should be
            # no explicit Users rules. With mock or without admin, we just verify the test runs.
            if ($script:UsingRealModule -and $script:IsAdmin) {
                $explicitUserRules | Should -BeNullOrEmpty -Because "Users should NOT have explicit access per v2.3.0 security model"
                Write-Host "Verified: No explicit Users access (v2.3.0 security model)"
            } else {
                Write-Host "Note: Using mock module or non-admin - explicit ACL verification limited"
                Write-Host "      Any Users access shown is inherited, not explicitly granted"
                $true | Should -BeTrue
            }
        }
        
        It 'Should have inheritance disabled (verified with Get-NTFSInheritance) [REQUIRES ADMIN]' -Skip:$script:SkipNonAdminTests {
            # This test requires admin privileges to modify ACLs
            # The -Skip parameter above handles non-admin execution
            
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $backupDir = $results[0].DestinationPath
            
            # Use NTFSSecurity module to verify inheritance is disabled
            $inheritance = Get-NTFSInheritance -Path $backupDir
            
            # AccessInheritanceEnabled = False means inheritance is disabled
            $inheritance.AccessInheritanceEnabled | Should -BeFalse -Because "Inheritance should be disabled on backup directory"
            Write-Host "Verified: Inheritance is disabled (AccessInheritanceEnabled = $($inheritance.AccessInheritanceEnabled))"
        }
    }
    
    Context 'Compress Mode - Actual ACL Verification' {
        It 'Should create ZIP archive with correct permissions' {
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $results | Should -Not -BeNullOrEmpty
            $results[0].Status | Should -Be 'Success'
            
            $zipFile = $results[0].DestinationPath
            $zipFile | Should -Exist
            $zipFile | Should -Match '\.zip$'
            
            # Verify ZIP file size
            $zipSize = (Get-Item -Path $zipFile).Length
            $zipSize | Should -BeGreaterThan 0
            
            Write-Host "Created ZIP archive: $zipFile (Size: $zipSize bytes)"
        }
        
        It 'Should set Administrators FullControl on ZIP archive (verified with Get-NTFSAccess)' {
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $zipFile = $results[0].DestinationPath
            
            # Use NTFSSecurity module to verify permissions
            $accessRules = Get-NTFSAccess -Path $zipFile
            $adminRules = $accessRules | Where-Object {
                $_.Account.AccountName -match 'Administrators' -and
                $_.AccessRights -match 'FullControl'
            }
            
            $adminRules | Should -Not -BeNullOrEmpty -Because "Administrators should have FullControl on ZIP archive"
            Write-Host "Verified: Administrators have FullControl on ZIP"
        }
        
        It 'Should have inheritance disabled on ZIP archive (verified with Get-NTFSInheritance) [REQUIRES ADMIN]' -Skip:$script:SkipNonAdminTests {
            # This test requires admin privileges to modify ACLs
            # The -Skip parameter above handles non-admin execution
            
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $zipFile = $results[0].DestinationPath
            
            # Use NTFSSecurity module to verify inheritance is disabled
            $inheritance = Get-NTFSInheritance -Path $zipFile
            
            $inheritance.AccessInheritanceEnabled | Should -BeFalse -Because "Inheritance should be disabled on ZIP archive"
            Write-Host "Verified: Inheritance is disabled on ZIP (AccessInheritanceEnabled = $($inheritance.AccessInheritanceEnabled))"
        }
    }
    
    Context 'ACL Summary Report' {
        It 'Should display full ACL details for verification' {
            $realAclBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'RealACL'
            
            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $realAclBackupPath `
                -BackupMode Mirror `
                -ProfilePattern '^10000$' `
                -NTFSSecurityModulePath $script:ModulePathToUse `
                -Confirm:$false
            
            $backupDir = $results[0].DestinationPath
            $accessRules = Get-NTFSAccess -Path $backupDir
            $inheritance = Get-NTFSInheritance -Path $backupDir
            
            Write-Host "`n=== ACL DETAILS FOR: $backupDir ===" -ForegroundColor Cyan
            Write-Host "Inheritance Enabled: $($inheritance.AccessInheritanceEnabled)" -ForegroundColor Yellow
            Write-Host "`nAccess Rules:" -ForegroundColor Yellow
            
            foreach ($rule in $accessRules) {
                Write-Host "  - Account: $($rule.Account)" -ForegroundColor White
                Write-Host "    Rights: $($rule.AccessRights)" -ForegroundColor Gray
                Write-Host "    Type: $($rule.AccessControlType)" -ForegroundColor Gray
                Write-Host "    Inherited: $($rule.IsInherited)" -ForegroundColor Gray
                Write-Host ""
            }
            
            # This test always passes - it's for visual verification
            $true | Should -BeTrue
        }
    }
}

Describe 'Backup-UserProfile Performance Tests' -Tag 'Integration', 'Performance' {
    BeforeAll {
        $mockModulePath = Join-Path -Path $script:OutputPath -ChildPath 'NTFSSecurity\NTFSSecurity.psd1'
    }

    Context 'Execution Time' {
        It 'Should complete backup of standard profiles within acceptable time' {
            $perfBackupPath = Join-Path -Path $script:TestBackupPath -ChildPath 'Performance'
            if (Test-Path -Path $perfBackupPath) {
                Remove-Item -Path $perfBackupPath -Recurse -Force
            }
            New-Item -Path $perfBackupPath -ItemType Directory -Force | Out-Null

            $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

            $results = Backup-UserProfile `
                -SourcePath $script:TestProfilesPath `
                -TargetPath $perfBackupPath `
                -BackupMode Compress `
                -ProfilePattern '^1000\d$' `
                -NTFSSecurityModulePath $mockModulePath `
                -Confirm:$false

            $stopwatch.Stop()

            # Should complete within 60 seconds for small test profiles
            $stopwatch.Elapsed.TotalSeconds | Should -BeLessThan 60

            Write-Host "Backup completed in $($stopwatch.Elapsed.TotalSeconds) seconds for $($results.Count) profiles"
        }
    }
}